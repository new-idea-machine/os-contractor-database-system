import { Timestamp, serverTimestamp } from "firebase/firestore";
import { isValidTimestamp } from "../constants/data";

class Conversation {
  // Class members
  #archivedBy = [];
  #deletedOnBy = [];
  #formerParticipants = [];
  #moderators = [];
  #participants = [];
  #starredBy = [];
  #subject = "";
  #createdOn = null; // generated by Firebase -- do not set manually!

  constructor(data = {}) {
    if (data && typeof data === "object" && !Array.isArray(data)) {
      // Initialize from data or use defaults
      this.#archivedBy = data.archivedBy || this.#archivedBy;
      this.#formerParticipants = data.formerParticipants || this.#formerParticipants;
      this.#moderators = data.moderators || this.#moderators;
      this.#participants = data.participants || this.#participants;
      this.#starredBy = data.starredBy || this.#starredBy;
      this.#subject = data.subject || this.#subject;
      this.#createdOn = data.createdOn || this.#createdOn;

      if (Array.isArray(data.deletedOnBy)) {
        data.deletedOnBy.forEach((entry) => {
          if (entry.userId && typeof entry.userId === "string" && entry.timestamp &&
            (entry.timestamp instanceof Date || isValidTimestamp(entry.timestamp))) {

            this.#deletedOnBy.push(entry);
          }
        });
      }
    }
  }

  // Getters
  get archivedBy() { return [...this.#archivedBy]; }
  get deletedOnBy() { return [...this.#deletedOnBy]; }
  get formerParticipants() { return [...this.#formerParticipants]; }
  get moderators() { return [...this.#moderators]; }
  get participants() { return [...this.#participants]; }
  get starredBy() { return [...this.#starredBy]; }
  get subject() { return this.#subject; }
  get createdOn() { return this.#createdOn; }

  // Setters with validation
  set archivedBy(value) {
    if (!Array.isArray(value) || value.some(id => typeof id !== "string" || id.trim() === "")) {
      throw new Error("ArchivedBy must be an array of non-empty strings");
    }
    this.#archivedBy = [...value];
  }

  set deletedOnBy(value) {
    if (!Array.isArray(value) || value.some(entry =>
      typeof entry !== "object" ||
      !entry.userId ||
      typeof entry.userId !== "string" ||
      (entry.timestamp !== null && !(entry.timestamp instanceof Date) && !isValidTimestamp(entry.timestamp))
    )) {
      throw new Error("DeletedOnBy must be an array of objects with userId and timestamp");
    }
    this.#deletedOnBy = [...value];
  }

  set formerParticipants(value) {
    if (!Array.isArray(value) || value.some(id => typeof id !== "string" || id.trim() === "")) {
      throw new Error("FormerParticipants must be an array of non-empty strings (no duplicates)");
    }
    this.#formerParticipants = [...value];
  }

  set moderators(value) {
    if (!Array.isArray(value) || value.some(id => typeof id !== "string" || id.trim() === "")) {
      throw new Error("Moderators must be an array of non-empty strings (no duplicates)");
    }
    this.#moderators = [...value];
  }

  set participants(value) {
    if (!Array.isArray(value) || value.some(id => typeof id !== "string" || id.trim() === "")) {
      throw new Error("Participants must be an array of non-empty strings (no duplicates)");
    }
    this.#participants = [...value];
  }

  set starredBy(value) {
    if (!Array.isArray(value) || value.some(id => typeof id !== "string" || id.trim() === "")) {
      throw new Error("StarredBy must be an array of non-empty strings (no duplicates)");
    }
    this.#starredBy = [...value];
  }

  set subject(value) {
    if (typeof value !== "string" || value.trim() === "") {
      throw new Error("Subject must be a non-empty string");
    }
    this.#subject = value;
  }

  // Methods
  validate() {
    if (!this.#subject || this.#subject.trim() === "") {
      throw new Error("Conversation subject is required");
    }

    if (!this.#participants || this.#participants.length < 2) {
      throw new Error("Conversation must have at least 2 participants");
    }

    // Ensure all moderators are also participants
    if (this.#moderators && this.#moderators.length > 0) {
      const nonParticipantModerators = this.#moderators.filter(
        (moderator) => !this.#participants.includes(moderator)
      );

      if (nonParticipantModerators.length > 0) {
        throw new Error("All moderators must also be participants");
      }
    }

    return true;
  }

  // Add a participant
  addParticipant(id) {
    if (typeof id !== "string" || id.trim() === "") {
      throw new Error("Participant ID must be a non-empty string");
    }

    if (!this.#participants.includes(id)) {
      this.#participants.push(id);

      // If they were previously removed, take them out of formerParticipants
      this.#formerParticipants = this.#formerParticipants.filter(
        participant => participant !== id
      );
    }
  }

  // Remove a participant
  removeParticipant(id) {
    if (typeof id !== "string" || id.trim() === "") {
      throw new Error("Participant ID must be a non-empty string");
    }

    if (this.#participants.includes(id)) {
      this.#participants = this.#participants.filter(
        participant => participant !== id
      );

      // Add to former participants list
      if (!this.#formerParticipants.includes(id)) {
        this.#formerParticipants.push(id);
      }

      // Also remove from moderators if present
      this.#moderators = this.#moderators.filter(
        moderator => moderator !== id
      );
    }
  }

  // Add a moderator (must be a participant)
  addModerator(id) {
    if (typeof id !== "string" || id.trim() === "") {
      throw new Error("Moderator ID must be a non-empty string");
    }

    if (!this.#participants.includes(id)) {
      throw new Error("User must be a participant before becoming a moderator");
    }

    if (!this.#moderators.includes(id)) {
      this.#moderators.push(id);
    }
  }

  // Remove a moderator
  removeModerator(id) {
    if (typeof id !== "string" || id.trim() === "") {
      throw new Error("Moderator ID must be a non-empty string");
    }

    this.#moderators = this.#moderators.filter(moderator => moderator !== id);
  }

  // Check if user is a participant
  isParticipant(id) {
    return this.#participants.includes(id);
  }

  // Check if user is a moderator
  isModerator(id) {
    return this.#moderators.includes(id);
  }

  // Archive conversation for a user
  archiveFor(userId) {
    if (typeof userId !== "string" || userId.trim() === "") {
      throw new Error("User ID must be a non-empty string");
    }

    if (!this.#archivedBy.includes(userId)) {
      this.#archivedBy.push(userId);
    }
  }

  // Unarchive conversation for a user
  unarchiveFor(userId) {
    if (typeof userId !== "string" || userId.trim() === "") {
      throw new Error("User ID must be a non-empty string");
    }

    this.#archivedBy = this.#archivedBy.filter(id => id !== userId);
  }

  // Check if archived by a user
  isArchivedBy(userId) {
    return this.#archivedBy.includes(userId);
  }

  // Star conversation for a user
  starFor(userId) {
    if (typeof userId !== "string" || userId.trim() === "") {
      throw new Error("User ID must be a non-empty string");
    }

    if (!this.#starredBy.includes(userId)) {
      this.#starredBy.push(userId);
    }
  }

  // Unstar conversation for a user
  unstarFor(userId) {
    if (typeof userId !== "string" || userId.trim() === "") {
      throw new Error("User ID must be a non-empty string");
    }

    this.#starredBy = this.#starredBy.filter(id => id !== userId);
  }

  // Check if starred by a user
  isStarredBy(userId) {
    return this.#starredBy.includes(userId);
  }

  // Delete conversation for a user
  deleteFor(userId) {
    if (typeof userId !== "string" || userId.trim() === "") {
      throw new Error("User ID must be a non-empty string");
    }

    const now = new Date();
    const deleteEntry = { userId, timestamp: now };

    // Remove any existing delete entry for this user
    this.#deletedOnBy = this.#deletedOnBy.filter(entry => entry.userId !== userId);

    // Add the new delete entry
    this.#deletedOnBy.push(deleteEntry);
  }

  // Undelete conversation for a user
  undeleteFor(userId) {
    if (typeof userId !== "string" || userId.trim() === "") {
      throw new Error("User ID must be a non-empty string");
    }

    this.#deletedOnBy = this.#deletedOnBy.filter(entry => entry.userId !== userId);
  }

  // Check if deleted by a user
  isDeletedBy(userId) {
    return this.#deletedOnBy.some(entry => entry.userId === userId);
  }

  // Get deletion timestamp for a user
  getDeletionTimestamp(userId) {
    const entry = this.#deletedOnBy.find(entry => entry.userId === userId);
    return entry ? entry.timestamp : null;
  }

  // Convert to Firebase document
  toFirebaseDocument() {
    const doc = {
      archivedBy: this.#archivedBy,
      deletedOnBy: this.#deletedOnBy.map(entry => ({
        userId: entry.userId,
        timestamp: entry.timestamp instanceof Date ? Timestamp.fromDate(entry.timestamp) : entry.timestamp
      })),
      formerParticipants: this.#formerParticipants,
      moderators: this.#moderators,
      participants: this.#participants,
      starredBy: this.#starredBy,
      subject: this.#subject
    };

    // Only include createdOn if we're creating a new document
    if (!this.#createdOn) {
      doc.createdOn = serverTimestamp();
    }

    return doc;
  }

  // Create from Firebase document
  static fromFirebaseDocument(doc) {
    if (!doc) return null;

    const data = doc.data();
    if (!data) return null;

    return new Conversation(data);
  }
}

export default Conversation;