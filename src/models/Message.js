import { Timestamp, serverTimestamp } from "firebase/firestore";
import { isValidTimestamp } from "../constants/data";

class Message {
  // Class members
  #conversationId = "";
  #archivedBy = []; // Array of UIDs
  #author = "";
  #deletedOnBy = []; // Array of objects with userId and timestamp
  #readBy = []; // Array of UIDs
  #starredBy = []; // Array of UIDs
  #text = "";
  #timestamp = null; // generated by Firebase -- do not set manually!

  constructor(data = {}) {
    if (data && typeof data === "object" && !Array.isArray(data)) {
      // Initialize from data or use defaults
      this.#conversationId = data.conversationId || this.#conversationId;
      this.#archivedBy = data.archivedBy || this.#archivedBy;
      this.#author = data.author || this.#author;
      this.#readBy = data.readBy || this.#readBy;
      this.#starredBy = data.starredBy || this.#starredBy;
      this.#text = data.text || this.#text;
      this.#timestamp = data.timestamp || this.#timestamp;

      if (Array.isArray(data.deletedOnBy)) {
        data.deletedOnBy.forEach((entry) => {
          if (entry.userId && typeof entry.userId === "string" && entry.timestamp &&
            (entry.timestamp instanceof Date || isValidTimestamp(entry.timestamp))) {
            this.#deletedOnBy.push(entry);
          }
        });
      }
    }
  }

  // Getters
  get conversationId() { return this.#conversationId; }
  get archivedBy() { return [...this.#archivedBy]; }
  get author() { return this.#author; }
  get deletedOnBy() { return [...this.#deletedOnBy]; }
  get readBy() { return [...this.#readBy]; }
  get starredBy() { return [...this.#starredBy]; }
  get text() { return this.#text; }
  get timestamp() { return this.#timestamp; }

  // Setters with validation
  set conversationId(value) {
    if (typeof value !== "string" || value.trim() === "") {
      throw new Error("Conversation ID must be a non-empty string");
    }
    this.#conversationId = value;
  }

  set archivedBy(userIds) {
    if (!Array.isArray(userIds) || userIds.some(id => typeof id !== "string" || id.trim() === "")) {
      throw new Error("ArchivedBy must be an array of non-empty strings");
    }
    this.#archivedBy = [...userIds];
  }

  set author(userId) {
    if (typeof userId !== "string" || userId.trim() === "") {
      throw new Error("Author must be a non-empty string");
    }
    this.#author = userId;
  }

  set deletedOnBy(objects) {
    if (!Array.isArray(objects) || objects.some(entry =>
      typeof entry !== "object" ||
      !entry.userId ||
      typeof entry.userId !== "string" ||
      (entry.timestamp !== null && !(entry.timestamp instanceof Date) && !isValidTimestamp(entry.timestamp))
    )) {
      throw new Error("DeletedOnBy must be an array of objects with userId and timestamp");
    }
    this.#deletedOnBy = [...objects];
  }

  set readBy(userIds) {
    if (!Array.isArray(userIds) || userIds.some(id => typeof id !== "string" || id.trim() === "")) {
      throw new Error("ReadBy must be an array of non-empty strings");
    }
    this.#readBy = [...userIds];
  }

  set starredBy(userIds) {
    if (!Array.isArray(userIds) || userIds.some(id => typeof id !== "string" || id.trim() === "")) {
      throw new Error("StarredBy must be an array of non-empty strings");
    }
    this.#starredBy = [...userIds];
  }

  set text(content) {
    if (typeof content !== "string" || content.trim() === "") {
      throw new Error("Text must be a non-empty string");
    }
    this.#text = content;
  }

  // Methods
  validate() {
    if (!this.#conversationId) {
      throw new Error('Conversation ID is required');
    }

    if (!this.#author) {
      throw new Error('Author is required');
    }

    if (!this.#text || this.#text.trim() === '') {
      throw new Error('Message text cannot be empty');
    }

    return true;
  }

  // Mark as read by a user
  markReadBy(userId) {
    if (typeof userId !== "string" || userId.trim() === "") {
      throw new Error("User ID must be a non-empty string");
    }

    if (!this.#readBy.includes(userId)) {
      this.#readBy.push(userId);
    }
  }

  // Check if read by a user
  isReadBy(userId) {
    return this.#readBy.includes(userId);
  }

  // Archive message for a user
  archiveFor(userId) {
    if (typeof userId !== "string" || userId.trim() === "") {
      throw new Error("User ID must be a non-empty string");
    }

    if (!this.#archivedBy.includes(userId)) {
      this.#archivedBy.push(userId);
    }
  }

  // Unarchive message for a user
  unarchiveFor(userId) {
    if (typeof userId !== "string" || userId.trim() === "") {
      throw new Error("User ID must be a non-empty string");
    }

    this.#archivedBy = this.#archivedBy.filter(id => id !== userId);
  }

  // Check if archived by a user
  isArchivedBy(userId) {
    return this.#archivedBy.includes(userId);
  }

  // Star message for a user
  starFor(userId) {
    if (typeof userId !== "string" || userId.trim() === "") {
      throw new Error("User ID must be a non-empty string");
    }

    if (!this.#starredBy.includes(userId)) {
      this.#starredBy.push(userId);
    }
  }

  // Unstar message for a user
  unstarFor(userId) {
    if (typeof userId !== "string" || userId.trim() === "") {
      throw new Error("User ID must be a non-empty string");
    }

    this.#starredBy = this.#starredBy.filter(id => id !== userId);
  }

  // Check if starred by a user
  isStarredBy(userId) {
    return this.#starredBy.includes(userId);
  }

  // Delete message for a user
  deleteFor(userId) {
    if (typeof userId !== "string" || userId.trim() === "") {
      throw new Error("User ID must be a non-empty string");
    }

    const now = new Date();
    const deletionInfo = { userId, timestamp: now };

    // Remove any existing delete entry for this user
    this.#deletedOnBy = this.#deletedOnBy.filter((deletionInfo) => deletionInfo.userId !== userId);

    // Add the new delete entry
    this.#deletedOnBy.push(deletionInfo);
  }

  // Undelete message for a user
  undeleteFor(userId) {
    if (typeof userId !== "string" || userId.trim() === "") {
      throw new Error("User ID must be a non-empty string");
    }

    this.#deletedOnBy = this.#deletedOnBy.filter((deletionInfo) => deletionInfo.userId !== userId);
  }

  // Check if deleted by a user
  isDeletedBy(userId) {
    return this.#deletedOnBy.some(entry => entry.userId === userId);
  }

  // Get deletion timestamp for a user
  getDeletionTimestamp(userId) {
    const deletionInfo = this.#deletedOnBy.find(entry => entry.userId === userId);
    return deletionInfo ? deletionInfo.timestamp : null;
  }

  // Convert to Firebase document
  toFirebaseDocument() {
    const doc = {
      conversationId: this.#conversationId,
      archivedBy: this.#archivedBy,
      author: this.#author,
      deletedOnBy: this.#deletedOnBy.map(entry => ({
        userId: entry.userId,
        timestamp: entry.timestamp instanceof Date ? Timestamp.fromDate(entry.timestamp) : entry.timestamp
      })),
      readBy: this.#readBy,
      starredBy: this.#starredBy,
      text: this.#text
    };

    // Only include timestamp if we're creating a new document
    if (!this.#timestamp) {
      doc.timestamp = serverTimestamp();
    }

    return doc;
  }

  // Create from Firebase document
  static fromFirebaseDocument(doc) {
    if (!doc) return null;

    const data = doc.data();
    if (!data) return null;

    return new Message(data);
  }
}

export default Message;